### 线程安全的实现方法

1. 互斥同步
2. 非阻塞同步
3. 无同步方案

### 死锁

#### 定义

是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种相互等待的现象，若无外力作用，它们将无法推进下去

#### 原因

1. 资源不足
2. 进程运行推进的顺序不对
3. 资源分配不当等

#### 四个必要条件

**互斥条件、不可抢占条件、占有申请且等待条件、循环等待条件**

- 互斥条件：某个资源在一段时间内只能有一个进程占有，不能同时被两个或者两个以上的进程占有。如打印机等
- 不可抢占条件：进程所获得的资源在没有使用完之前，资源申请者不能强行地从资源占有者手中夺取资源，只能由该资源的占有者进程自行释放。
- 占有申请且等待条件：进程至少已经占有一个资源，但又申请新的资源；由于申请的资源已经被另一个进程占有，此时进程阻塞；但在等待新资源时，仍然继续占用已有的资源。
- 循环等待条件：存在一个进程等待序列{P1,P2,P3…，Pn},其中P1等待P2，P2等待P3,…Pn等待P1所占有的资源，形成了一个进程循环等待环。

#### 处理死锁的方法

**死锁预防、死锁避免、死锁检测、死锁接触**

- 死锁预防：通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。 

  1. 打破互斥条件：它是设备的固有属性所决定的，不仅不能改变，还应该加以保证 
  2. 打破不可抢占：
     自己释放：如果占有某些资源的一个进程进行进一步资源请求时被拒绝，则该进程必须释放它最初占有的资源
     占有的线程释放：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另外一个进程，要求它释放资源 
  3. 打破占有申请且等待：为了预防占有且等待条件，可以要求进程一次性的请求所需要的资源，若不能满足，阻塞这个进程等待所有请求都同时被满足
     缺点：不完全能确定执行时所需要的资源、资源利用率降低、降低了进程的并发性
  4. 打破循环等待：通过定义资源类型的线性顺序来预防 
     缺点:

- 死锁避免：满足前三个必要条件，谨慎选择，确保不会到达死锁点。比死锁预防多了更多的并发

  1. 安全序列算法：系统中的所有进程能够按照某一种次序分配资源，并且依次地运行完毕，这种进程序列{P1，P2，...，Pn}就是安全序列。如果存在这样一个安全序列，则系统是安全的；如果系统不存在这样一个安全序列，则系统是不安全的。 

  2. 银行家算法：
     1.如果request<=need，转向步骤2；否则认为出错，因为请求资源大于需要资源。

     2.如果request<=available，转向步骤3,；否则尚无足够资源，进程p阻塞；

     3.系统尝试为把资源分配给进程P，并修改available、allocation和need的数值。

     4.系统执行安全性算法，检查此次分配后系统是否处于安全状态，若安全，才正式将资源分配给进程P，否则将本次试探性分配作废，让进程P等待。

     **安全状态** ：系统能按照某种进程顺序，为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。

  3. 安全性算法：1.设置两个向量：

     - 工作向量work：表示系统可提供给进程继续运行的所需的各类资源的数目，执行安全算法开始时，work=available。
     - finish：表示系统是否有足够资源分配给进程，使之运行完成。开始时先做finish[i]=false；当有足够资源分配给进程时再令finish[i]=true。

     2.从进程集合找到一个满足下列条件的进程：

     - finish[i]=false；
     - need<=work；
     - 若找到执行步骤3；否则执行步骤4；

     3.当进程P获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：

     - work=work+allocation(P)；
     - finish[i]=true；
     - 循环执行步骤2；

     4.如果所有进程的finish=true，则表示系统处于安全状态；否则，系统处于不安全状态。

- 死锁检测：不采取任何的措施，允许系统在运行时发生死锁，通过系统设置死锁检测机构及时检测死锁，确定发生死锁的进程和资源，采取适当措施，接触死锁

- 死锁解除：当系统检测到死锁后，解除死锁
  常用方法：剥夺资源和撤销进程

参考地址：

1. https://blog.csdn.net/rabbit_in_android/article/details/50530960
2. https://blog.csdn.net/abigale1011/article/details/6450845

### synchronized和ReentrantLock的区别

- synchronized是Java关键字，依赖jvm实现 ，ReentrantLock是一个类，ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量
- 都是加锁方式同步，而且都是阻塞式的同步 
- ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能 ：  
  1. 等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。
  2. 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。
  3. 锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。



### 并发编程的三要素

1. **原子性** ：原子，即一个不可再被分割的颗粒。在Java中原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。
2. **有序性** ：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）
3. **可见性** ：当多个线程访问同一个变量时，如果其中一个线程对其作了修改，其他线程能立即获取到最新的值。

### 多线程相关问题

#### 作用：

   - 发挥多核CPU的优势
     单核CPU上所谓“多线程”其实是并发的模式实现的多线程。同一时间处理器只会处理一段逻辑，只不过线程之间的切换的比较快，看起来像多个线程“同时运行”。
     多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥多核的优势。
   - 防止阻塞
     单核CPU的多线程，虽然不能发挥多线程的性能，但是可以防止线程阻塞。不至于某个线程阻塞了，导致整个程序停止
   - 便于建模
     一个大的任务A，单线程编程，需要考虑很多，但是可以将一个大的任务A分解成多个小任务，采用多线程去处

#### 创建方式：
   两种：
   > 继承Thread()类  
   >
   > 实现Runnable接口

   第二种方式相对于第一种方式更好，因为实现接口的方式比继承类的方式更加灵活（Java是单继承的），也能减少程序的耦合度，面向接口的编程也是设计模式的核心。

#### start()方法和run()方法的区别
只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只调用run()方法，代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕，另一个线程才可以执行run（）方法里面的代码

#### Runnable接口和Callable接口的区别
Runnable接口的run()方法的返回值是void,它做的事情只是纯粹地去执行run()方法中的代码而已
Callable接口的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果

#### **CyclicBarrier和CountDownLatch的区别** 

   - CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行 
     CountDownLatch不是，某线程运行到某个点上之后，只是给某个数值-1，线程继续运行
   - CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 
   - CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 

#### volatile关键字的作用

   - 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，每次读取到volatile变量，一定是最新的数据
   - 代码执行过程：Java代码-->字节码-->根据字节码执行对应的C/C++代码-->C/C++代码被编译成汇编语言-->和硬件电路相互交互。现实中为了获取更好的性能JVM会对指令进行指令重排序，多线程先就有可能出现不一样的结果。使用**volatile可以禁止指令重排序**

#### 线程安全

当多个线程访问一个对象时，如果不考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。

#### 线程安全的级别

   - 不可变：
      String，Integer，Long这些，都是final类型的类，任何一个线程都改变不了他们的值，除非新建，所以在任何地方都可以在多线程环境下使用。
   - 绝对线程安全
      不管运行时环境如何，调用者都不需要额外的同步措施。 CopyOnWriteArrayList、CopyOnWriteArraySet 
   - 相对线程安全
      相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是**fail-fast机制**。 
   - 线程非安全
      ArrayList、LinkedList、HashMap等都是线程非安全的类 

#### 线程出现了运行时异常结果
   如果这个异常没有被捕获,则程序会停止运行。若这个线程持有某个对象的监视器，那么这个对象会被监视器立即释放。

####  sleep方法和wait方法有什么区别

   - sleep方法和wait方法都可以用来放弃CPU一定时间，
   - 不同点在于如果线程持有某个对象的监视器，sleep不会放弃这个对象的监视器,wait方法会放弃这个对象的监视器。

####  生产者和消费者模型的作用

   - 通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者和消费者模型最重要的作用。
   - 解耦。意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互制约

#### 为什么要使用线程池

- 降低资源消耗，避免频繁的创建和销毁线程，达到线程对象的重用
- 提高响应速度（不一定），当任务到达时，可以不需要等待线程的创建
- 提高线程的可管理性，通过线程池的统一分配，调优和监控。

#### 线程类的构造方法，静态块时被哪个线程调用的
   线程类的构造方法，静态块时被new这个线程类所在的线程所调用的，而run方法里面的代码时被线程自身所调用的。
   eg：Thread2中new了Thread1,main函数中new了一个Thread2，则：
   - Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的
   - Thread1的构造方法，静态块是main线程调用的，Thread1的run()方法是Thread1自己调用的

#### 高并发，任务执行时间问题

高并发，任务执行时间短的业务怎样使用线程池？并发不高，任务执行时间长的业务怎样使用线程池？并发高，任务执行时间长的业务怎样使用线程池？

   - 高并发，时间短：减少线程池的数量，减少线程上下文切换。一般设置为CPU核数+1
   - 并发不高，时间长：
   - 业务时间长，集中在IO操作上，IO密集型，因为IO操作不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中线程数目，让CPU处理更多的业务
   - 业务时间长，集中在计算操作上，也就是计算密集型的话，只能减少线程池大小，减少线程上下文切换
   - 并发高，业务时间长：解决问题的关键点在于优化整体架构设计，看看这些业务里面某些数据是否能缓存是第一步，增加服务器是第二步，至于线程设置可参考并发不高，业务时间长。
   - 对于业务时间长的问题，可能需要分析一下，看能不能使用中间件对任务进行拆分和解耦



