#### 索引选择性

1. 是不是只要是查询语句需要，就建上索引 ？多索引
   不是，索引虽然加快了查询速度，但索引也是有代价的。
   - 索引文件本身要消耗存储空间
   - 加重插入、删除和修改记录的负担
   - Mysql运行时也要消耗资源维护索引

2. 不建议建索引：
   - 表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了
   - 不建议建索引的情况是索引的选择性较低

3. 索引优化：
   - 前缀索引，减少索引长度，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。

4. InnoDB引擎的优化和选择

   - 永远使用一个与业务无关的自增字段作为主键
   - 原因：InnoDB的实现采用的是聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上,这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）
   - 表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。形成一个紧凑的索引结构，近似顺序填满,由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。 
   - 使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置 ,不得不为了将新记录插入到合适的位置而移动数据，甚至需要读盘。

5. 创建索引可以大大提高系统的性能

   第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

   第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

   第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

   第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

   第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

6. 增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？
   因为，增加索引也有许多不利的方面。 
   第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

   第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

   第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

7. 第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性 

8. 第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。 

9. 第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 

#### 数据库事务

[参考地址](https://www.cnblogs.com/fjdingsd/p/5273008.html)

##### 事务的四个特性（ACID）

- 原子性：事务包含的所有操作，要么全部成功，要么全部失败回滚。
- 一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态
- 隔离性：当多个用户并发的访问数据库，数据库为每个用户开启事务，每个事务不能被其他事务的操作所干扰，过个并发事务之间相互隔离
- 持久性：一个事务一旦被提交，对数据库中的数据的改变是永久性的，即使是在数据库系统遇到故障的情况下也不会丢失事务提交的操作

##### 不考虑事务隔离性的后果

- 脏读：一个事务处理过程中读取另一个事务未提交的事务中的数据
- 不可重复读：对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的结果。
- 虚读（幻读）：事务非独立执行时发生的一种现象。
  不可重复读和幻读都是读取到了另一个事务已提交的数据，而脏读是读到了另一个事务未提交的数据。不可重复读读得都是同一条数据，幻读读的都是一批数据整体。

##### Mysql数据库的四种隔离级别

- 串行化（Serializable ）：可避免脏读、不可重复读、幻读
- 可重复读（Repeatable read ）：可避免脏读、不可重复读，**Mysql中所使用的隔离级别。** 
- 读已提交（Read committed ）：可避免脏读
- 读未提交（Read uncommitted ）：任何情况都无法保证

#### Hibernate和MyBatis的比较

##### 开发速度对比：

- Hibernate掌握难道要比Mybatis难
- Mabatis更适合复杂语句较多的项目，可以自己写Sql语句
- Hibernate适合于没有复杂查询逻辑的项目，基本的sql语句已经被封装好了

##### 开发工作量对比

- Hibernate 和MyBatis都有代码生成工具。可以生成简单基本的DAO层方法，针对高级查询，MyBatis需要手动编写SQL语句，以及RestMap。Hibernate无需关心SQL的生成与结果映射，可以专注于业务流程
- H有日志统计，M没有

##### sql优化方面

- H查询时会将所有字段都查询出来，会有性能消耗。M的Sql语句自己手动编写，可以避免

##### 对象管理的对比

- H是完整的对象/关系映射解决方案，提供了对象状态管理的功能。M没有，需要用户对对象自己进行详细的管理

##### 缓存机制

- H 缓存
  H一级缓存是Session缓存，二级缓存为SessionFactory级缓存。

- M缓存
  包含了一个很强大的查询缓存特性，可以很方便的配置和定制。

- 相同点：

  H和M的二级缓存除了采用系统默认缓存机制外，都可以实现自己的缓存或者第三方缓存方案，创建适配器来完全覆盖缓存行为
  都支持JDBC和JTA事务处理

- 不同点：
  H的二级缓存配置在SessionFactory生成的配置文件中进行详细的配置，再在具体表-对象映射中配置那种缓存。
  M的二级缓存配置都是在每个具体的表-对象中进行详细的配置，针对不同的表可以定义不同的缓存机制。

- 比较：
  H对查询对象有着良好的管理机制，用户无需关心SQL.所以在使用二级缓存时如果出现脏数据，系统会报出错误提示

  M这方面，在使用二级缓存的时候需要特别小心。不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患

##### MyBatis优势

- 可以进行更为细致的Sql优化，可以减少查询字段
- 容易掌握

##### Hibernate优势

- 不需要维护SQL和结果映射
- 对象的维护和缓存比M好，对增删改查的对象维护更方便
- 移植性更好，M的移植性不好，不同的数据库需要写不同的SQL
- 有更好的二级缓存机制，可以使用第三方缓存。Mybatis本身提供的缓存机制不佳



