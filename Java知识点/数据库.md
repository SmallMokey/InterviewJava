### 聚集索引和非聚集索引的区别

**根本区别** ：表记录的排列顺序与索引的排列顺序是否一致   

1. 聚集索引表记录的排列顺序与索引的排列顺序一致
   - 优点：查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。
   - 缺点：是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排， 降低了执行速度。
   - 建议使用聚集索引的场合  
     - 此列包含有限数目的不同值
     - 查询的结果返回一个区间的值
     - 查询的结果返回某值相同的大量结果集
2. 非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引顺序不一致
   - 索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针的方式
   - 非聚集索引比聚集索引层次多，添加记录不会引起数据顺序的重组
   - 建议使用非聚集索引的场合
     - 此列包含了大量数目不同的值
     - 查询的结束返回的是少量的结果集
     -  order by 子句中使用了该列

### 索引选择性

1. 是不是只要是查询语句需要，就建上索引 ？多索引
   不是，索引虽然加快了查询速度，但索引也是有代价的。

   - 索引文件本身要消耗存储空间
   - 加重插入、删除和修改记录的负担
   - Mysql运行时也要消耗资源维护索引

2. 不建议建索引：
   - 表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了
   - 不建议建索引的情况是索引的选择性较低

3. 索引优化：

   - 前缀索引，减少索引长度，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。

4. InnoDB引擎的优化和选择

   - 永远使用一个与业务无关的自增字段作为主键
   - 原因：InnoDB的实现采用的是聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上,这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）
   - 表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。形成一个紧凑的索引结构，近似顺序填满,由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。 
   - 使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置 ,不得不为了将新记录插入到合适的位置而移动数据，甚至需要读盘。

5. 创建索引可以大大提高系统的性能

   第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

   第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

   第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

   第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

   第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

6. 增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？
   因为，增加索引也有许多不利的方面。 
   第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

   第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

   第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

7. 第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性 

8. 第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。 

9. 第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 

### 数据库事务

[参考地址](https://www.cnblogs.com/fjdingsd/p/5273008.html)

#### 事务的四个特性（ACID）

- 原子性：事务包含的所有操作，要么全部成功，要么全部失败回滚。
- 一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态
- 隔离性：当多个用户并发的访问数据库，数据库为每个用户开启事务，每个事务不能被其他事务的操作所干扰，过个并发事务之间相互隔离
- 持久性：一个事务一旦被提交，对数据库中的数据的改变是永久性的，即使是在数据库系统遇到故障的情况下也不会丢失事务提交的操作

#### 不考虑事务隔离性的后果

- 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
- 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致
- 虚读（幻读）：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读
  **不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表**

#### Mysql数据库的四种隔离级别

- 串行化（Serializable ）：可避免脏读、不可重复读、幻读
- 可重复读（Repeatable read ）：可避免脏读、不可重复读，**Mysql中所使用的隔离级别。**   
  可重复读的隔离级别下使用了MVCC机制，A事务中读取的是记录的快照版本，而非最新版本，B事务的更新是创建了一个新版本来更新，不同事务的读和写是分离的
- 读已提交（Read committed ）：可避免脏读
- 读未提交（Read uncommitted ）：任何情况都无法保证

参考链接：https://www.cnblogs.com/huanongying/p/7021555.html

### Hibernate和MyBatis的比较

#### 开发速度对比：

- Hibernate掌握难道要比Mybatis难
- Mabatis更适合复杂语句较多的项目，可以自己写Sql语句
- Hibernate适合于没有复杂查询逻辑的项目，基本的sql语句已经被封装好了

#### 开发工作量对比

- Hibernate 和MyBatis都有代码生成工具。可以生成简单基本的DAO层方法，针对高级查询，MyBatis需要手动编写SQL语句，以及RestMap。Hibernate无需关心SQL的生成与结果映射，可以专注于业务流程
- H有日志统计，M没有

#### sql优化方面

- H查询时会将所有字段都查询出来，会有性能消耗。M的Sql语句自己手动编写，可以避免

#### 对象管理的对比

- H是完整的对象/关系映射解决方案，提供了对象状态管理的功能。M没有，需要用户对对象自己进行详细的管理

#### 缓存机制

- H 缓存
  H一级缓存是Session缓存，二级缓存为SessionFactory级缓存。

- M缓存
  包含了一个很强大的查询缓存特性，可以很方便的配置和定制。

- 相同点：

  H和M的二级缓存除了采用系统默认缓存机制外，都可以实现自己的缓存或者第三方缓存方案，创建适配器来完全覆盖缓存行为
  都支持JDBC和JTA事务处理

- 不同点：
  H的二级缓存配置在SessionFactory生成的配置文件中进行详细的配置，再在具体表-对象映射中配置那种缓存。
  M的二级缓存配置都是在每个具体的表-对象中进行详细的配置，针对不同的表可以定义不同的缓存机制。

- 比较：
  H对查询对象有着良好的管理机制，用户无需关心SQL.所以在使用二级缓存时如果出现脏数据，系统会报出错误提示

  M这方面，在使用二级缓存的时候需要特别小心。不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患

#### MyBatis优势

- 可以进行更为细致的Sql优化，可以减少查询字段
- 容易掌握

#### Hibernate优势

- 不需要维护SQL和结果映射
- 对象的维护和缓存比M好，对增删改查的对象维护更方便
- 移植性更好，M的移植性不好，不同的数据库需要写不同的SQL
- 有更好的二级缓存机制，可以使用第三方缓存。Mybatis本身提供的缓存机制不佳



