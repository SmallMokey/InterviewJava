### Java内存模型

Java内存模型（Java Memory Model,简称JMM）。定义了Java虚拟机（JVM）在计算机内存（RAM）中的工作方式。定义了多线程之间共享变量可见性以及如何在需要的时候对共享变量进行同步。
### 关于并发编程
并发中两个关键问题：通信和同步。
1、线程的通信：线程之间以何种机制来交换信息。命令式编程中，有共享内存和消息传递两种方式
&emsp;&emsp;共享内存：线程之间共享线程的公共状态，线程通过读-写内存中的公共状态来隐式进行通信，典型通信方式：共享对象
&emsp;&emsp;消息传递：消息之间没有公共状态，线程之间通过明确的发送消息来显式进行通信，java典型的消息传递方式就是wait()和notify()

2、线程同步：程序用于控制不同线程之间操作发生顺序
&emsp;&emsp;共享内存的并发模式中，同步是显式的。程序员必须显式的指定某个方法或代码需要在线程之间互斥执行
&emsp;&emsp;消息传递并发模式中，消息的发送必须在消息接收之前，通信是隐式的

**Java的采用共享内存的方式实现线程同步**

JMM决定一个线程对共享变量的写入何时对另一个线程可见，定义了线程和主存之间的抽象关系：线程之间的共享变量存储在主内存(Main memory)中，每个线程都有一个私有的本地内存（Local memory),本地内存中存储了该线程以读/写共享变量的副本。
注：本地内存是JMM的一个抽象概念，并不真实存在
![内存模型](F:\找工作相关\Java知识点\JVM和并发\img\内存模型.png)
线程A与线程B如果想要通信的话，需要：
> 1.线程A把本地内存A中更新过的共享变量刷新到主内存中去 
> 2.线程B到主内存中去读取线程A更新过的共享变量

###  JVM对Java内存模型的实现

java内存模型内部把内存分成两部分：`线程栈区`和`堆区`
![](F:\找工作相关\Java知识点\JVM和并发\img\Java内存模型在JVM中的逻辑视图.png)

> JVM中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，称为调用栈。随着代码的不断执行，调用栈会不断变化。 

> 线程栈包含了当前方法的所有本地变量信息。
> 一个线程只能读取自己的线程栈，线程中的本地变量对其它线程是不可见的。即使两个线程执行的是同一段代码，它们会各自在自己的线程栈中创建本地变量，因此，每个线程中的本地变量都会有自己的版本。 

> 原始类型（byte、boolean、char、short、int、long、float、double）的本地变量都直接保存在线程栈中，每个线程中这些值都是相互独立不可见的。当他们无法共享时，一个线程可以传递一个副本给另一个线程。

> 堆区（Heap）存放Java应用创建的所有对象信息。不管对象是哪个线程创建或者对象属于一个成员变量还是方法中的本地变量，都被存储在堆区

![](F:\找工作相关\Java知识点\JVM\img\调用栈和本地变量和对象存储位置.png)
**本地变量存储位置：**

> 原始类型：栈区
> 对一个对象的引用：本地引用存储在栈区，对象本身存在在堆区

**对象的存储位置：**

> 成员方法：方法中包含了本地变量，所以存储在栈区
> 成员变量：不管是包装类型还是基本类型，都存放在堆区

**Static类型的变量和类本身的相关信息随类本身存储在堆区**

> 注：对象存储在堆区可以本多个线程共享，多个线程获得对象之后，则获得对象的成员变量，但对于本地变量，每个线程都会拷贝一份到自己的线程中。

### 共享对象的可见性

多个线程同时操作同一个共享对象时，如果没有合理的使用volatile和synchronization关键字，一个线程对共享对象的更新有可能导致其它线程不可见 。
![](F:\找工作相关\Java知识点\JVM\img\共享对象的可见性.png)
CPU一个线程读取主存中的数据到CPU缓存，对于共享对象进行了更改，对于其他CPU线程是不可见的。
使用volatile 关键字：可以保证变量会直接从主存读取，而对变量的更新会直接写到主存中，对所有线程可见。
原理：基于CPU的内存屏障指令实现

###  竞争现象

多个线程共享一个对象，同时修改这个共享对象，就出现竞争现象。
![](F:\找工作相关\Java知识点\JVM\img\竞争现象.png)
解决方法：使用synchronized代码块。可以保证同一时刻只能有一个线程进入代码竞争区，synchronized代码块保证代码块中所有变量都会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。

###  Java内存模型的基础原理

**指令重排序**是在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的`Memory Barrier`来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。
1. 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序：如果不存l在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

**数据依赖性**
如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。

**as-if-serial**
不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime和处理器都必须遵守as-if-serial语义。

**内存屏障（Memory Barrier）**
内存屏障，又称内存栅栏，是一个CPU指令：

> 1.保证特定操作的执行顺序。
> 2.影响某些数据（或者是某条指令的执行结果）的内存可见性。

内存屏障告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。

Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个`Write-Barrier`（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。 

java内存模型中的volatile是基于`内存屏障`实现的。

如果一个变量是`volatile`修饰的，JMM会在写入这个字段之后插进一个`Write-Barrier`指令，并在读这个字段之前插入一个`Read-Barrier`指令。这意味着，如果写入一个`volatile`变量，就可以保证：

1. 一个线程写入变量a后，任何线程访问该变量都会拿到最新值。
2. 在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。

### happens-before

在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系
这两个操作可以是在同一个线程中，也可以在不同的线程中
happens-before规则：

1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。
2. 监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。
3. volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
4. 传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。

注：两个操作之间具有happens-before关系，并不意味着前一个操作必须在后一个操作之前执行！仅仅要求前一个操作的执行结果对后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。 