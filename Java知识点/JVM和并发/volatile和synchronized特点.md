线程安全的两个方面：**执行控制**和**内存可见**
**执行控制：**目的是控制代码执行（顺序）及是否可以并发执行
**内存可见：**控制线程执行结果在内存中对其他线程的可见性

## Synchronized

`synchronized`关键字解决的是执行控制的问题。

> 它会阻止其它线程获取当前对象的监控锁，就使得当前对象中被`synchronized`关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，`synchronized`还会创建一个**内存屏障**，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都**happens-before**于随后获得这个锁的线程的操作。 

## Volatile

`volatile`关键字解决的是内存可见性的问题。

> 会使得所有对`volatile`变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。 

volatile关键字仅仅能实现对基本类型变量操作的原子性，不能保证复合操作的原子性。
当且仅当满足下面条件才可使用：
1.  对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
2.  该变量没有包含在具有其他变量的不变式中。 

##  Volatile和Synchronized的区别

1. volatile本质是告诉jvm当前变量在寄存器中（本地内存）的值是不确定的，需要从主存中读取数据，
   synchronized 是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞
2. volatile 使用在变量级，
   synchronized可以使用在变量、方法和类级别。
3. volatile仅能保证变量的修改可见性，不能保证原子性，
   synchronized可以保证修改可见性和原子性
4. synchronized会造成线程阻塞，volatile则不会
5. volatile标记的变量不会被编译器优化，synchronize标记的变量可以被优化