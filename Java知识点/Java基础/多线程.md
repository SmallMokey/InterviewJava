#### 多线程

1. 作用：

   - 发挥多核CPU的优势
     单核CPU上所谓“多线程”其实是并发的模式实现的多线程。同一时间处理器只会处理一段逻辑，只不过线程之间的切换的比较快，看起来像多个线程“同时运行”。
     多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥多核的优势。
   - 防止阻塞
     单核CPU的多线程，虽然不能发挥多线程的性能，但是可以防止线程阻塞。不至于某个线程阻塞了，导致整个程序停止
   - 便于建模
     一个大的任务A，单线程编程，需要考虑很多，但是可以将一个大的任务A分解成多个小任务，采用多线程去处

2. 创建方式：

   两种：
   > 1. 继承Thread()类
   > 2. 实现Runnable接口

   第二种方式相对于第一种方式更好，因为实现接口的方式比继承类的方式更加灵活（Java是单继承的），也能减少程序的耦合度，面向接口的编程也是设计模式的核心。
   

3. start()方法和run()方法的区别
   只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只调用run()方法，代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕，另一个线程才可以执行run（）方法里面的代码
   

4. Runnable接口和Callable接口的区别
   Runnable接口的run()方法的返回值是void,它做的事情只是纯粹地去执行run()方法中的代码而已
   Callable接口的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果
   

5. **CyclicBarrier和CountDownLatch的区别** 

   - CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行 
     CountDownLatch不是，某线程运行到某个点上之后，只是给某个数值-1，线程继续运行
   - CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 
   - CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 

   

6. volatile关键字的作用

   - 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，每次读取到volatile变量，一定是最新的数据
   - 代码执行过程：Java代码-->字节码-->根据字节码执行对应的C/C++代码-->C/C++代码被编译成汇编语言-->和硬件电路相互交互。现实中为了获取更好的性能JVM会对指令进行指令重排序，多线程先就有可能出现不一样的结果。使用**volatile可以禁止指令重排序**

7. 线程安全？
   通俗定义：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。
   线程安全的级别:

   - 不可变：
     String，Integer，Long这些，都是final类型的类，任何一个线程都改变不了他们的值，除非新建，所以在任何地方都可以在多线程环境下使用。
   - 绝对线程安全
     不管运行时环境如何，调用者都不需要额外的同步措施。 CopyOnWriteArrayList、CopyOnWriteArraySet 
   - 相对线程安全
     相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是**fail-fast机制**。 
   - 线程非安全
     ArrayList、LinkedList、HashMap等都是线程非安全的类 

8. 线程出现了运行时异常结果
   如果这个异常没有被捕获,则程序会停止运行。若这个线程持有某个对象的监视器，那么这个对象会被监视器立即释放。

9. sleep方法和wait方法有什么区别

   - sleep方法和wait方法都可以用来放弃CPU一定时间，
   - 不同点在于如果线程持有某个对象的监视器，sleep不会放弃这个对象的监视器,wait方法会放弃这个对象的监视器。

10. 生产者和消费者模型的作用

    - 通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者和消费者模型最重要的作用。
    - 解耦。意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互制约

11. 为什么要使用线程池
    避免频繁的创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目的灵活地控制并发的数目。

12. 线程类的构造方法，静态块时被哪个线程调用的
    线程类的构造方法，静态块时被new这个线程类所在的线程所调用的，而run方法里面的代码时被线程自身所调用的。
    eg：Thread2中new了Thread1,main函数中new了一个Thread2，则：

    - Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的
    - Thread1的构造方法，静态块是main线程调用的，Thread1的run()方法是Thread1自己调用的

13. 高并发，任务执行时间短的业务怎样使用线程池？
    并发不高，任务执行时间长的业务怎样使用线程池？
    并发高，任务执行时间长的业务怎样使用线程池？

    - 高并发，时间短：减少线程池的数量，减少线程上下文切换。一般设置为CPU核数+1
    - 并发不高，时间长：
      - 业务时间长，集中在IO操作上，IO密集型，因为IO操作不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中线程数目，让CPU处理更多的业务
      - 业务时间长，集中在计算操作上，也就是计算密集型的话，只能减少线程池大小，减少线程上下文切换
    - 并发高，业务时间长：解决问题的关键点在于优化整体架构设计，看看这些业务里面某些数据是否能缓存是第一步，增加服务器是第二步，至于线程设置可参考并发不高，业务时间长。
    - 对于业务时间长的问题，可能需要分析一下，看能不能使用中间件对任务进行拆分和解耦

